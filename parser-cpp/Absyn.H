#ifndef CHALKFRONTEND_ABSYN_HEADER
#define CHALKFRONTEND_ABSYN_HEADER

#include<string>
#include<vector>

//C++ Abstract Syntax Interface generated by the BNF Converter.
namespace CHALKFrontend
{
/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;




/********************   Forward Declarations    ********************/

class Cell;
class CellData;
class CBLOCK;
class PAD;
class PROPERTY;
class XYRELATIVE;
class XYABSOLUTE;
class Element;
class PLACEMENT;
class TEXT;
class XELEMENT;
class Geometry;
class POLYGON;
class PATH;
class TRAPEZOID;
class CTRAPEZOID;
class CIRCLE;
class XGEOMETRY;
class RECTANGLE;
class RectangleInfoByte;
class LayerData;
class LayerNumber;
class DataTypeNumber;
class Width;
class Height;
class XCoord;
class YCoord;
class Repetition;
class Int;
class ECell;
class CellDataCBLOCK;
class CellDataPAD;
class CellDataPROPERTY;
class CellDataXYRELATIVE;
class CellDataXYABSOLUTE;
class CellDataElement;
class ECBLOCK;
class EPAD;
class EPROPERTY;
class EXYRELATIVE;
class EXYABSOLUTE;
class ElementGeometry;
class ElementPLACEMENT;
class ElementTEXT;
class ElementXELEMENT;
class EPLACEMENT;
class ETEXT;
class EXELEMENT;
class GeometryRECTANGLE;
class GeometryPOLYGON;
class GeometryPATH;
class GeometryTRAPEZOID;
class GeometryCTRAPEZOID;
class GeometryCIRCLE;
class GeometryXGEOMETRY;
class EPOLYGON;
class EPATH;
class ETRAPEZOID;
class ECTRAPEZOID;
class ECIRCLE;
class EXGEOMETRY;
class ERECTANGLE;
class ERectangleInfoByte;
class ELayerData;
class ELayerNumber;
class EDataTypeNumber;
class EWidth;
class EHeight;
class EXCoord;
class EYCoord;
class ERepetition;
class EInt;
class ListCellData;
class ListLayerNumber;
class ListDataTypeNumber;
class ListWidth;
class ListHeight;
class ListXCoord;
class ListYCoord;
class ListRepetition;


/********************   Visitor Interfaces    ********************/
class Visitor
{
public:
  virtual ~Visitor() {}
  virtual void visitCell(Cell *p) = 0;
  virtual void visitCellData(CellData *p) = 0;
  virtual void visitCBLOCK(CBLOCK *p) = 0;
  virtual void visitPAD(PAD *p) = 0;
  virtual void visitPROPERTY(PROPERTY *p) = 0;
  virtual void visitXYRELATIVE(XYRELATIVE *p) = 0;
  virtual void visitXYABSOLUTE(XYABSOLUTE *p) = 0;
  virtual void visitElement(Element *p) = 0;
  virtual void visitPLACEMENT(PLACEMENT *p) = 0;
  virtual void visitTEXT(TEXT *p) = 0;
  virtual void visitXELEMENT(XELEMENT *p) = 0;
  virtual void visitGeometry(Geometry *p) = 0;
  virtual void visitPOLYGON(POLYGON *p) = 0;
  virtual void visitPATH(PATH *p) = 0;
  virtual void visitTRAPEZOID(TRAPEZOID *p) = 0;
  virtual void visitCTRAPEZOID(CTRAPEZOID *p) = 0;
  virtual void visitCIRCLE(CIRCLE *p) = 0;
  virtual void visitXGEOMETRY(XGEOMETRY *p) = 0;
  virtual void visitRECTANGLE(RECTANGLE *p) = 0;
  virtual void visitRectangleInfoByte(RectangleInfoByte *p) = 0;
  virtual void visitLayerData(LayerData *p) = 0;
  virtual void visitLayerNumber(LayerNumber *p) = 0;
  virtual void visitDataTypeNumber(DataTypeNumber *p) = 0;
  virtual void visitWidth(Width *p) = 0;
  virtual void visitHeight(Height *p) = 0;
  virtual void visitXCoord(XCoord *p) = 0;
  virtual void visitYCoord(YCoord *p) = 0;
  virtual void visitRepetition(Repetition *p) = 0;
  virtual void visitInt(Int *p) = 0;
  virtual void visitECell(ECell *p) = 0;
  virtual void visitCellDataCBLOCK(CellDataCBLOCK *p) = 0;
  virtual void visitCellDataPAD(CellDataPAD *p) = 0;
  virtual void visitCellDataPROPERTY(CellDataPROPERTY *p) = 0;
  virtual void visitCellDataXYRELATIVE(CellDataXYRELATIVE *p) = 0;
  virtual void visitCellDataXYABSOLUTE(CellDataXYABSOLUTE *p) = 0;
  virtual void visitCellDataElement(CellDataElement *p) = 0;
  virtual void visitECBLOCK(ECBLOCK *p) = 0;
  virtual void visitEPAD(EPAD *p) = 0;
  virtual void visitEPROPERTY(EPROPERTY *p) = 0;
  virtual void visitEXYRELATIVE(EXYRELATIVE *p) = 0;
  virtual void visitEXYABSOLUTE(EXYABSOLUTE *p) = 0;
  virtual void visitElementGeometry(ElementGeometry *p) = 0;
  virtual void visitElementPLACEMENT(ElementPLACEMENT *p) = 0;
  virtual void visitElementTEXT(ElementTEXT *p) = 0;
  virtual void visitElementXELEMENT(ElementXELEMENT *p) = 0;
  virtual void visitEPLACEMENT(EPLACEMENT *p) = 0;
  virtual void visitETEXT(ETEXT *p) = 0;
  virtual void visitEXELEMENT(EXELEMENT *p) = 0;
  virtual void visitGeometryRECTANGLE(GeometryRECTANGLE *p) = 0;
  virtual void visitGeometryPOLYGON(GeometryPOLYGON *p) = 0;
  virtual void visitGeometryPATH(GeometryPATH *p) = 0;
  virtual void visitGeometryTRAPEZOID(GeometryTRAPEZOID *p) = 0;
  virtual void visitGeometryCTRAPEZOID(GeometryCTRAPEZOID *p) = 0;
  virtual void visitGeometryCIRCLE(GeometryCIRCLE *p) = 0;
  virtual void visitGeometryXGEOMETRY(GeometryXGEOMETRY *p) = 0;
  virtual void visitEPOLYGON(EPOLYGON *p) = 0;
  virtual void visitEPATH(EPATH *p) = 0;
  virtual void visitETRAPEZOID(ETRAPEZOID *p) = 0;
  virtual void visitECTRAPEZOID(ECTRAPEZOID *p) = 0;
  virtual void visitECIRCLE(ECIRCLE *p) = 0;
  virtual void visitEXGEOMETRY(EXGEOMETRY *p) = 0;
  virtual void visitERECTANGLE(ERECTANGLE *p) = 0;
  virtual void visitERectangleInfoByte(ERectangleInfoByte *p) = 0;
  virtual void visitELayerData(ELayerData *p) = 0;
  virtual void visitELayerNumber(ELayerNumber *p) = 0;
  virtual void visitEDataTypeNumber(EDataTypeNumber *p) = 0;
  virtual void visitEWidth(EWidth *p) = 0;
  virtual void visitEHeight(EHeight *p) = 0;
  virtual void visitEXCoord(EXCoord *p) = 0;
  virtual void visitEYCoord(EYCoord *p) = 0;
  virtual void visitERepetition(ERepetition *p) = 0;
  virtual void visitEInt(EInt *p) = 0;
  virtual void visitListCellData(ListCellData *p) = 0;
  virtual void visitListLayerNumber(ListLayerNumber *p) = 0;
  virtual void visitListDataTypeNumber(ListDataTypeNumber *p) = 0;
  virtual void visitListWidth(ListWidth *p) = 0;
  virtual void visitListHeight(ListHeight *p) = 0;
  virtual void visitListXCoord(ListXCoord *p) = 0;
  virtual void visitListYCoord(ListYCoord *p) = 0;
  virtual void visitListRepetition(ListRepetition *p) = 0;


  virtual void visitInteger(Integer x) = 0;
  virtual void visitChar(Char x) = 0;
  virtual void visitDouble(Double x) = 0;
  virtual void visitString(String x) = 0;
  virtual void visitIdent(Ident x) = 0;

};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual void accept(Visitor *v) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class Cell : public Visitable
{
public:
  virtual Cell *clone() const = 0;

};

class CellData : public Visitable
{
public:
  virtual CellData *clone() const = 0;

};

class CBLOCK : public Visitable
{
public:
  virtual CBLOCK *clone() const = 0;

};

class PAD : public Visitable
{
public:
  virtual PAD *clone() const = 0;

};

class PROPERTY : public Visitable
{
public:
  virtual PROPERTY *clone() const = 0;

};

class XYRELATIVE : public Visitable
{
public:
  virtual XYRELATIVE *clone() const = 0;

};

class XYABSOLUTE : public Visitable
{
public:
  virtual XYABSOLUTE *clone() const = 0;

};

class Element : public Visitable
{
public:
  virtual Element *clone() const = 0;

};

class PLACEMENT : public Visitable
{
public:
  virtual PLACEMENT *clone() const = 0;

};

class TEXT : public Visitable
{
public:
  virtual TEXT *clone() const = 0;

};

class XELEMENT : public Visitable
{
public:
  virtual XELEMENT *clone() const = 0;

};

class Geometry : public Visitable
{
public:
  virtual Geometry *clone() const = 0;

};

class POLYGON : public Visitable
{
public:
  virtual POLYGON *clone() const = 0;

};

class PATH : public Visitable
{
public:
  virtual PATH *clone() const = 0;

};

class TRAPEZOID : public Visitable
{
public:
  virtual TRAPEZOID *clone() const = 0;

};

class CTRAPEZOID : public Visitable
{
public:
  virtual CTRAPEZOID *clone() const = 0;

};

class CIRCLE : public Visitable
{
public:
  virtual CIRCLE *clone() const = 0;

};

class XGEOMETRY : public Visitable
{
public:
  virtual XGEOMETRY *clone() const = 0;

};

class RECTANGLE : public Visitable
{
public:
  virtual RECTANGLE *clone() const = 0;

};

class RectangleInfoByte : public Visitable
{
public:
  virtual RectangleInfoByte *clone() const = 0;

};

class LayerData : public Visitable
{
public:
  virtual LayerData *clone() const = 0;

};

class LayerNumber : public Visitable
{
public:
  virtual LayerNumber *clone() const = 0;

};

class DataTypeNumber : public Visitable
{
public:
  virtual DataTypeNumber *clone() const = 0;

};

class Width : public Visitable
{
public:
  virtual Width *clone() const = 0;

};

class Height : public Visitable
{
public:
  virtual Height *clone() const = 0;

};

class XCoord : public Visitable
{
public:
  virtual XCoord *clone() const = 0;

};

class YCoord : public Visitable
{
public:
  virtual YCoord *clone() const = 0;

};

class Repetition : public Visitable
{
public:
  virtual Repetition *clone() const = 0;

};

class Int : public Visitable
{
public:
  virtual Int *clone() const = 0;

};



class ECell : public Cell
{
public:
  ListCellData *listcelldata_;

  ECell(const ECell &);
  ECell &operator=(const ECell &);
  ECell(ListCellData *p1);
  ~ECell();
  virtual void accept(Visitor *v);
  virtual ECell *clone() const;
  void swap(ECell &);
};

class CellDataCBLOCK : public CellData
{
public:
  CBLOCK *cblock_;

  CellDataCBLOCK(const CellDataCBLOCK &);
  CellDataCBLOCK &operator=(const CellDataCBLOCK &);
  CellDataCBLOCK(CBLOCK *p1);
  ~CellDataCBLOCK();
  virtual void accept(Visitor *v);
  virtual CellDataCBLOCK *clone() const;
  void swap(CellDataCBLOCK &);
};

class CellDataPAD : public CellData
{
public:
  PAD *pad_;

  CellDataPAD(const CellDataPAD &);
  CellDataPAD &operator=(const CellDataPAD &);
  CellDataPAD(PAD *p1);
  ~CellDataPAD();
  virtual void accept(Visitor *v);
  virtual CellDataPAD *clone() const;
  void swap(CellDataPAD &);
};

class CellDataPROPERTY : public CellData
{
public:
  PROPERTY *property_;

  CellDataPROPERTY(const CellDataPROPERTY &);
  CellDataPROPERTY &operator=(const CellDataPROPERTY &);
  CellDataPROPERTY(PROPERTY *p1);
  ~CellDataPROPERTY();
  virtual void accept(Visitor *v);
  virtual CellDataPROPERTY *clone() const;
  void swap(CellDataPROPERTY &);
};

class CellDataXYRELATIVE : public CellData
{
public:
  XYRELATIVE *xyrelative_;

  CellDataXYRELATIVE(const CellDataXYRELATIVE &);
  CellDataXYRELATIVE &operator=(const CellDataXYRELATIVE &);
  CellDataXYRELATIVE(XYRELATIVE *p1);
  ~CellDataXYRELATIVE();
  virtual void accept(Visitor *v);
  virtual CellDataXYRELATIVE *clone() const;
  void swap(CellDataXYRELATIVE &);
};

class CellDataXYABSOLUTE : public CellData
{
public:
  XYABSOLUTE *xyabsolute_;

  CellDataXYABSOLUTE(const CellDataXYABSOLUTE &);
  CellDataXYABSOLUTE &operator=(const CellDataXYABSOLUTE &);
  CellDataXYABSOLUTE(XYABSOLUTE *p1);
  ~CellDataXYABSOLUTE();
  virtual void accept(Visitor *v);
  virtual CellDataXYABSOLUTE *clone() const;
  void swap(CellDataXYABSOLUTE &);
};

class CellDataElement : public CellData
{
public:
  Element *element_;

  CellDataElement(const CellDataElement &);
  CellDataElement &operator=(const CellDataElement &);
  CellDataElement(Element *p1);
  ~CellDataElement();
  virtual void accept(Visitor *v);
  virtual CellDataElement *clone() const;
  void swap(CellDataElement &);
};

class ECBLOCK : public CBLOCK
{
public:

  ECBLOCK(const ECBLOCK &);
  ECBLOCK &operator=(const ECBLOCK &);
  ECBLOCK();
  ~ECBLOCK();
  virtual void accept(Visitor *v);
  virtual ECBLOCK *clone() const;
  void swap(ECBLOCK &);
};

class EPAD : public PAD
{
public:

  EPAD(const EPAD &);
  EPAD &operator=(const EPAD &);
  EPAD();
  ~EPAD();
  virtual void accept(Visitor *v);
  virtual EPAD *clone() const;
  void swap(EPAD &);
};

class EPROPERTY : public PROPERTY
{
public:

  EPROPERTY(const EPROPERTY &);
  EPROPERTY &operator=(const EPROPERTY &);
  EPROPERTY();
  ~EPROPERTY();
  virtual void accept(Visitor *v);
  virtual EPROPERTY *clone() const;
  void swap(EPROPERTY &);
};

class EXYRELATIVE : public XYRELATIVE
{
public:

  EXYRELATIVE(const EXYRELATIVE &);
  EXYRELATIVE &operator=(const EXYRELATIVE &);
  EXYRELATIVE();
  ~EXYRELATIVE();
  virtual void accept(Visitor *v);
  virtual EXYRELATIVE *clone() const;
  void swap(EXYRELATIVE &);
};

class EXYABSOLUTE : public XYABSOLUTE
{
public:

  EXYABSOLUTE(const EXYABSOLUTE &);
  EXYABSOLUTE &operator=(const EXYABSOLUTE &);
  EXYABSOLUTE();
  ~EXYABSOLUTE();
  virtual void accept(Visitor *v);
  virtual EXYABSOLUTE *clone() const;
  void swap(EXYABSOLUTE &);
};

class ElementGeometry : public Element
{
public:
  Geometry *geometry_;

  ElementGeometry(const ElementGeometry &);
  ElementGeometry &operator=(const ElementGeometry &);
  ElementGeometry(Geometry *p1);
  ~ElementGeometry();
  virtual void accept(Visitor *v);
  virtual ElementGeometry *clone() const;
  void swap(ElementGeometry &);
};

class ElementPLACEMENT : public Element
{
public:
  PLACEMENT *placement_;

  ElementPLACEMENT(const ElementPLACEMENT &);
  ElementPLACEMENT &operator=(const ElementPLACEMENT &);
  ElementPLACEMENT(PLACEMENT *p1);
  ~ElementPLACEMENT();
  virtual void accept(Visitor *v);
  virtual ElementPLACEMENT *clone() const;
  void swap(ElementPLACEMENT &);
};

class ElementTEXT : public Element
{
public:
  TEXT *text_;

  ElementTEXT(const ElementTEXT &);
  ElementTEXT &operator=(const ElementTEXT &);
  ElementTEXT(TEXT *p1);
  ~ElementTEXT();
  virtual void accept(Visitor *v);
  virtual ElementTEXT *clone() const;
  void swap(ElementTEXT &);
};

class ElementXELEMENT : public Element
{
public:
  XELEMENT *xelement_;

  ElementXELEMENT(const ElementXELEMENT &);
  ElementXELEMENT &operator=(const ElementXELEMENT &);
  ElementXELEMENT(XELEMENT *p1);
  ~ElementXELEMENT();
  virtual void accept(Visitor *v);
  virtual ElementXELEMENT *clone() const;
  void swap(ElementXELEMENT &);
};

class EPLACEMENT : public PLACEMENT
{
public:

  EPLACEMENT(const EPLACEMENT &);
  EPLACEMENT &operator=(const EPLACEMENT &);
  EPLACEMENT();
  ~EPLACEMENT();
  virtual void accept(Visitor *v);
  virtual EPLACEMENT *clone() const;
  void swap(EPLACEMENT &);
};

class ETEXT : public TEXT
{
public:

  ETEXT(const ETEXT &);
  ETEXT &operator=(const ETEXT &);
  ETEXT();
  ~ETEXT();
  virtual void accept(Visitor *v);
  virtual ETEXT *clone() const;
  void swap(ETEXT &);
};

class EXELEMENT : public XELEMENT
{
public:

  EXELEMENT(const EXELEMENT &);
  EXELEMENT &operator=(const EXELEMENT &);
  EXELEMENT();
  ~EXELEMENT();
  virtual void accept(Visitor *v);
  virtual EXELEMENT *clone() const;
  void swap(EXELEMENT &);
};

class GeometryRECTANGLE : public Geometry
{
public:
  RECTANGLE *rectangle_;

  GeometryRECTANGLE(const GeometryRECTANGLE &);
  GeometryRECTANGLE &operator=(const GeometryRECTANGLE &);
  GeometryRECTANGLE(RECTANGLE *p1);
  ~GeometryRECTANGLE();
  virtual void accept(Visitor *v);
  virtual GeometryRECTANGLE *clone() const;
  void swap(GeometryRECTANGLE &);
};

class GeometryPOLYGON : public Geometry
{
public:
  POLYGON *polygon_;

  GeometryPOLYGON(const GeometryPOLYGON &);
  GeometryPOLYGON &operator=(const GeometryPOLYGON &);
  GeometryPOLYGON(POLYGON *p1);
  ~GeometryPOLYGON();
  virtual void accept(Visitor *v);
  virtual GeometryPOLYGON *clone() const;
  void swap(GeometryPOLYGON &);
};

class GeometryPATH : public Geometry
{
public:
  PATH *path_;

  GeometryPATH(const GeometryPATH &);
  GeometryPATH &operator=(const GeometryPATH &);
  GeometryPATH(PATH *p1);
  ~GeometryPATH();
  virtual void accept(Visitor *v);
  virtual GeometryPATH *clone() const;
  void swap(GeometryPATH &);
};

class GeometryTRAPEZOID : public Geometry
{
public:
  TRAPEZOID *trapezoid_;

  GeometryTRAPEZOID(const GeometryTRAPEZOID &);
  GeometryTRAPEZOID &operator=(const GeometryTRAPEZOID &);
  GeometryTRAPEZOID(TRAPEZOID *p1);
  ~GeometryTRAPEZOID();
  virtual void accept(Visitor *v);
  virtual GeometryTRAPEZOID *clone() const;
  void swap(GeometryTRAPEZOID &);
};

class GeometryCTRAPEZOID : public Geometry
{
public:
  CTRAPEZOID *ctrapezoid_;

  GeometryCTRAPEZOID(const GeometryCTRAPEZOID &);
  GeometryCTRAPEZOID &operator=(const GeometryCTRAPEZOID &);
  GeometryCTRAPEZOID(CTRAPEZOID *p1);
  ~GeometryCTRAPEZOID();
  virtual void accept(Visitor *v);
  virtual GeometryCTRAPEZOID *clone() const;
  void swap(GeometryCTRAPEZOID &);
};

class GeometryCIRCLE : public Geometry
{
public:
  CIRCLE *circle_;

  GeometryCIRCLE(const GeometryCIRCLE &);
  GeometryCIRCLE &operator=(const GeometryCIRCLE &);
  GeometryCIRCLE(CIRCLE *p1);
  ~GeometryCIRCLE();
  virtual void accept(Visitor *v);
  virtual GeometryCIRCLE *clone() const;
  void swap(GeometryCIRCLE &);
};

class GeometryXGEOMETRY : public Geometry
{
public:
  XGEOMETRY *xgeometry_;

  GeometryXGEOMETRY(const GeometryXGEOMETRY &);
  GeometryXGEOMETRY &operator=(const GeometryXGEOMETRY &);
  GeometryXGEOMETRY(XGEOMETRY *p1);
  ~GeometryXGEOMETRY();
  virtual void accept(Visitor *v);
  virtual GeometryXGEOMETRY *clone() const;
  void swap(GeometryXGEOMETRY &);
};

class EPOLYGON : public POLYGON
{
public:

  EPOLYGON(const EPOLYGON &);
  EPOLYGON &operator=(const EPOLYGON &);
  EPOLYGON();
  ~EPOLYGON();
  virtual void accept(Visitor *v);
  virtual EPOLYGON *clone() const;
  void swap(EPOLYGON &);
};

class EPATH : public PATH
{
public:

  EPATH(const EPATH &);
  EPATH &operator=(const EPATH &);
  EPATH();
  ~EPATH();
  virtual void accept(Visitor *v);
  virtual EPATH *clone() const;
  void swap(EPATH &);
};

class ETRAPEZOID : public TRAPEZOID
{
public:

  ETRAPEZOID(const ETRAPEZOID &);
  ETRAPEZOID &operator=(const ETRAPEZOID &);
  ETRAPEZOID();
  ~ETRAPEZOID();
  virtual void accept(Visitor *v);
  virtual ETRAPEZOID *clone() const;
  void swap(ETRAPEZOID &);
};

class ECTRAPEZOID : public CTRAPEZOID
{
public:

  ECTRAPEZOID(const ECTRAPEZOID &);
  ECTRAPEZOID &operator=(const ECTRAPEZOID &);
  ECTRAPEZOID();
  ~ECTRAPEZOID();
  virtual void accept(Visitor *v);
  virtual ECTRAPEZOID *clone() const;
  void swap(ECTRAPEZOID &);
};

class ECIRCLE : public CIRCLE
{
public:

  ECIRCLE(const ECIRCLE &);
  ECIRCLE &operator=(const ECIRCLE &);
  ECIRCLE();
  ~ECIRCLE();
  virtual void accept(Visitor *v);
  virtual ECIRCLE *clone() const;
  void swap(ECIRCLE &);
};

class EXGEOMETRY : public XGEOMETRY
{
public:

  EXGEOMETRY(const EXGEOMETRY &);
  EXGEOMETRY &operator=(const EXGEOMETRY &);
  EXGEOMETRY();
  ~EXGEOMETRY();
  virtual void accept(Visitor *v);
  virtual EXGEOMETRY *clone() const;
  void swap(EXGEOMETRY &);
};

class ERECTANGLE : public RECTANGLE
{
public:
  RectangleInfoByte *rectangleinfobyte_;
  LayerData *layerdata_;
  ListWidth *listwidth_;
  ListHeight *listheight_;
  ListXCoord *listxcoord_;
  ListYCoord *listycoord_;
  ListRepetition *listrepetition_;

  ERECTANGLE(const ERECTANGLE &);
  ERECTANGLE &operator=(const ERECTANGLE &);
  ERECTANGLE(RectangleInfoByte *p1, LayerData *p2, ListWidth *p3, ListHeight *p4, ListXCoord *p5, ListYCoord *p6, ListRepetition *p7);
  ~ERECTANGLE();
  virtual void accept(Visitor *v);
  virtual ERECTANGLE *clone() const;
  void swap(ERECTANGLE &);
};

class ERectangleInfoByte : public RectangleInfoByte
{
public:
  Int *int_;

  ERectangleInfoByte(const ERectangleInfoByte &);
  ERectangleInfoByte &operator=(const ERectangleInfoByte &);
  ERectangleInfoByte(Int *p1);
  ~ERectangleInfoByte();
  virtual void accept(Visitor *v);
  virtual ERectangleInfoByte *clone() const;
  void swap(ERectangleInfoByte &);
};

class ELayerData : public LayerData
{
public:
  LayerNumber *layernumber_;
  DataTypeNumber *datatypenumber_;

  ELayerData(const ELayerData &);
  ELayerData &operator=(const ELayerData &);
  ELayerData(LayerNumber *p1, DataTypeNumber *p2);
  ~ELayerData();
  virtual void accept(Visitor *v);
  virtual ELayerData *clone() const;
  void swap(ELayerData &);
};

class ELayerNumber : public LayerNumber
{
public:
  Int *int_;

  ELayerNumber(const ELayerNumber &);
  ELayerNumber &operator=(const ELayerNumber &);
  ELayerNumber(Int *p1);
  ~ELayerNumber();
  virtual void accept(Visitor *v);
  virtual ELayerNumber *clone() const;
  void swap(ELayerNumber &);
};

class EDataTypeNumber : public DataTypeNumber
{
public:
  Int *int_;

  EDataTypeNumber(const EDataTypeNumber &);
  EDataTypeNumber &operator=(const EDataTypeNumber &);
  EDataTypeNumber(Int *p1);
  ~EDataTypeNumber();
  virtual void accept(Visitor *v);
  virtual EDataTypeNumber *clone() const;
  void swap(EDataTypeNumber &);
};

class EWidth : public Width
{
public:
  Int *int_;

  EWidth(const EWidth &);
  EWidth &operator=(const EWidth &);
  EWidth(Int *p1);
  ~EWidth();
  virtual void accept(Visitor *v);
  virtual EWidth *clone() const;
  void swap(EWidth &);
};

class EHeight : public Height
{
public:
  Int *int_;

  EHeight(const EHeight &);
  EHeight &operator=(const EHeight &);
  EHeight(Int *p1);
  ~EHeight();
  virtual void accept(Visitor *v);
  virtual EHeight *clone() const;
  void swap(EHeight &);
};

class EXCoord : public XCoord
{
public:
  Int *int_;

  EXCoord(const EXCoord &);
  EXCoord &operator=(const EXCoord &);
  EXCoord(Int *p1);
  ~EXCoord();
  virtual void accept(Visitor *v);
  virtual EXCoord *clone() const;
  void swap(EXCoord &);
};

class EYCoord : public YCoord
{
public:
  Int *int_;

  EYCoord(const EYCoord &);
  EYCoord &operator=(const EYCoord &);
  EYCoord(Int *p1);
  ~EYCoord();
  virtual void accept(Visitor *v);
  virtual EYCoord *clone() const;
  void swap(EYCoord &);
};

class ERepetition : public Repetition
{
public:

  ERepetition(const ERepetition &);
  ERepetition &operator=(const ERepetition &);
  ERepetition();
  ~ERepetition();
  virtual void accept(Visitor *v);
  virtual ERepetition *clone() const;
  void swap(ERepetition &);
};

class EInt : public Int
{
public:
  Integer integer_;

  EInt(const EInt &);
  EInt &operator=(const EInt &);
  EInt(Integer p1);
  ~EInt();
  virtual void accept(Visitor *v);
  virtual EInt *clone() const;
  void swap(EInt &);
};



class ListCellData : public Visitable, public std::vector<CellData*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListCellData *clone() const;
};

class ListLayerNumber : public Visitable, public std::vector<LayerNumber*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListLayerNumber *clone() const;
};

class ListDataTypeNumber : public Visitable, public std::vector<DataTypeNumber*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListDataTypeNumber *clone() const;
};

class ListWidth : public Visitable, public std::vector<Width*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListWidth *clone() const;
};

class ListHeight : public Visitable, public std::vector<Height*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListHeight *clone() const;
};

class ListXCoord : public Visitable, public std::vector<XCoord*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListXCoord *clone() const;
};

class ListYCoord : public Visitable, public std::vector<YCoord*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListYCoord *clone() const;
};

class ListRepetition : public Visitable, public std::vector<Repetition*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListRepetition *clone() const;
};


}
#endif
