//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include <string>
#include <vector>
#include "Absyn.H"
namespace CHALKFrontend
{
/********************   ECell    ********************/
ECell::ECell(ListCellData *p1)
{
  listcelldata_ = p1;

}

ECell::ECell(const ECell & other)
{
  listcelldata_ = other.listcelldata_->clone();

}

ECell &ECell::operator=(const ECell & other)
{
  ECell tmp(other);
  swap(tmp);
  return *this;
}

void ECell::swap(ECell & other)
{
  std::swap(listcelldata_, other.listcelldata_);

}

ECell::~ECell()
{
  delete(listcelldata_);

}

void ECell::accept(Visitor *v)
{
  v->visitECell(this);
}

ECell *ECell::clone() const
{
  return new ECell(*this);
}



/********************   CellDataCBLOCK    ********************/
CellDataCBLOCK::CellDataCBLOCK(CBLOCK *p1)
{
  cblock_ = p1;

}

CellDataCBLOCK::CellDataCBLOCK(const CellDataCBLOCK & other)
{
  cblock_ = other.cblock_->clone();

}

CellDataCBLOCK &CellDataCBLOCK::operator=(const CellDataCBLOCK & other)
{
  CellDataCBLOCK tmp(other);
  swap(tmp);
  return *this;
}

void CellDataCBLOCK::swap(CellDataCBLOCK & other)
{
  std::swap(cblock_, other.cblock_);

}

CellDataCBLOCK::~CellDataCBLOCK()
{
  delete(cblock_);

}

void CellDataCBLOCK::accept(Visitor *v)
{
  v->visitCellDataCBLOCK(this);
}

CellDataCBLOCK *CellDataCBLOCK::clone() const
{
  return new CellDataCBLOCK(*this);
}



/********************   CellDataPAD    ********************/
CellDataPAD::CellDataPAD(PAD *p1)
{
  pad_ = p1;

}

CellDataPAD::CellDataPAD(const CellDataPAD & other)
{
  pad_ = other.pad_->clone();

}

CellDataPAD &CellDataPAD::operator=(const CellDataPAD & other)
{
  CellDataPAD tmp(other);
  swap(tmp);
  return *this;
}

void CellDataPAD::swap(CellDataPAD & other)
{
  std::swap(pad_, other.pad_);

}

CellDataPAD::~CellDataPAD()
{
  delete(pad_);

}

void CellDataPAD::accept(Visitor *v)
{
  v->visitCellDataPAD(this);
}

CellDataPAD *CellDataPAD::clone() const
{
  return new CellDataPAD(*this);
}



/********************   CellDataPROPERTY    ********************/
CellDataPROPERTY::CellDataPROPERTY(PROPERTY *p1)
{
  property_ = p1;

}

CellDataPROPERTY::CellDataPROPERTY(const CellDataPROPERTY & other)
{
  property_ = other.property_->clone();

}

CellDataPROPERTY &CellDataPROPERTY::operator=(const CellDataPROPERTY & other)
{
  CellDataPROPERTY tmp(other);
  swap(tmp);
  return *this;
}

void CellDataPROPERTY::swap(CellDataPROPERTY & other)
{
  std::swap(property_, other.property_);

}

CellDataPROPERTY::~CellDataPROPERTY()
{
  delete(property_);

}

void CellDataPROPERTY::accept(Visitor *v)
{
  v->visitCellDataPROPERTY(this);
}

CellDataPROPERTY *CellDataPROPERTY::clone() const
{
  return new CellDataPROPERTY(*this);
}



/********************   CellDataXYRELATIVE    ********************/
CellDataXYRELATIVE::CellDataXYRELATIVE(XYRELATIVE *p1)
{
  xyrelative_ = p1;

}

CellDataXYRELATIVE::CellDataXYRELATIVE(const CellDataXYRELATIVE & other)
{
  xyrelative_ = other.xyrelative_->clone();

}

CellDataXYRELATIVE &CellDataXYRELATIVE::operator=(const CellDataXYRELATIVE & other)
{
  CellDataXYRELATIVE tmp(other);
  swap(tmp);
  return *this;
}

void CellDataXYRELATIVE::swap(CellDataXYRELATIVE & other)
{
  std::swap(xyrelative_, other.xyrelative_);

}

CellDataXYRELATIVE::~CellDataXYRELATIVE()
{
  delete(xyrelative_);

}

void CellDataXYRELATIVE::accept(Visitor *v)
{
  v->visitCellDataXYRELATIVE(this);
}

CellDataXYRELATIVE *CellDataXYRELATIVE::clone() const
{
  return new CellDataXYRELATIVE(*this);
}



/********************   CellDataXYABSOLUTE    ********************/
CellDataXYABSOLUTE::CellDataXYABSOLUTE(XYABSOLUTE *p1)
{
  xyabsolute_ = p1;

}

CellDataXYABSOLUTE::CellDataXYABSOLUTE(const CellDataXYABSOLUTE & other)
{
  xyabsolute_ = other.xyabsolute_->clone();

}

CellDataXYABSOLUTE &CellDataXYABSOLUTE::operator=(const CellDataXYABSOLUTE & other)
{
  CellDataXYABSOLUTE tmp(other);
  swap(tmp);
  return *this;
}

void CellDataXYABSOLUTE::swap(CellDataXYABSOLUTE & other)
{
  std::swap(xyabsolute_, other.xyabsolute_);

}

CellDataXYABSOLUTE::~CellDataXYABSOLUTE()
{
  delete(xyabsolute_);

}

void CellDataXYABSOLUTE::accept(Visitor *v)
{
  v->visitCellDataXYABSOLUTE(this);
}

CellDataXYABSOLUTE *CellDataXYABSOLUTE::clone() const
{
  return new CellDataXYABSOLUTE(*this);
}



/********************   CellDataElement    ********************/
CellDataElement::CellDataElement(Element *p1)
{
  element_ = p1;

}

CellDataElement::CellDataElement(const CellDataElement & other)
{
  element_ = other.element_->clone();

}

CellDataElement &CellDataElement::operator=(const CellDataElement & other)
{
  CellDataElement tmp(other);
  swap(tmp);
  return *this;
}

void CellDataElement::swap(CellDataElement & other)
{
  std::swap(element_, other.element_);

}

CellDataElement::~CellDataElement()
{
  delete(element_);

}

void CellDataElement::accept(Visitor *v)
{
  v->visitCellDataElement(this);
}

CellDataElement *CellDataElement::clone() const
{
  return new CellDataElement(*this);
}



/********************   ECBLOCK    ********************/
ECBLOCK::ECBLOCK()
{

}

ECBLOCK::ECBLOCK(const ECBLOCK & other)
{

}

ECBLOCK &ECBLOCK::operator=(const ECBLOCK & other)
{
  ECBLOCK tmp(other);
  swap(tmp);
  return *this;
}

void ECBLOCK::swap(ECBLOCK & other)
{

}

ECBLOCK::~ECBLOCK()
{

}

void ECBLOCK::accept(Visitor *v)
{
  v->visitECBLOCK(this);
}

ECBLOCK *ECBLOCK::clone() const
{
  return new ECBLOCK(*this);
}



/********************   EPAD    ********************/
EPAD::EPAD()
{

}

EPAD::EPAD(const EPAD & other)
{

}

EPAD &EPAD::operator=(const EPAD & other)
{
  EPAD tmp(other);
  swap(tmp);
  return *this;
}

void EPAD::swap(EPAD & other)
{

}

EPAD::~EPAD()
{

}

void EPAD::accept(Visitor *v)
{
  v->visitEPAD(this);
}

EPAD *EPAD::clone() const
{
  return new EPAD(*this);
}



/********************   EPROPERTY    ********************/
EPROPERTY::EPROPERTY()
{

}

EPROPERTY::EPROPERTY(const EPROPERTY & other)
{

}

EPROPERTY &EPROPERTY::operator=(const EPROPERTY & other)
{
  EPROPERTY tmp(other);
  swap(tmp);
  return *this;
}

void EPROPERTY::swap(EPROPERTY & other)
{

}

EPROPERTY::~EPROPERTY()
{

}

void EPROPERTY::accept(Visitor *v)
{
  v->visitEPROPERTY(this);
}

EPROPERTY *EPROPERTY::clone() const
{
  return new EPROPERTY(*this);
}



/********************   EXYRELATIVE    ********************/
EXYRELATIVE::EXYRELATIVE()
{

}

EXYRELATIVE::EXYRELATIVE(const EXYRELATIVE & other)
{

}

EXYRELATIVE &EXYRELATIVE::operator=(const EXYRELATIVE & other)
{
  EXYRELATIVE tmp(other);
  swap(tmp);
  return *this;
}

void EXYRELATIVE::swap(EXYRELATIVE & other)
{

}

EXYRELATIVE::~EXYRELATIVE()
{

}

void EXYRELATIVE::accept(Visitor *v)
{
  v->visitEXYRELATIVE(this);
}

EXYRELATIVE *EXYRELATIVE::clone() const
{
  return new EXYRELATIVE(*this);
}



/********************   EXYABSOLUTE    ********************/
EXYABSOLUTE::EXYABSOLUTE()
{

}

EXYABSOLUTE::EXYABSOLUTE(const EXYABSOLUTE & other)
{

}

EXYABSOLUTE &EXYABSOLUTE::operator=(const EXYABSOLUTE & other)
{
  EXYABSOLUTE tmp(other);
  swap(tmp);
  return *this;
}

void EXYABSOLUTE::swap(EXYABSOLUTE & other)
{

}

EXYABSOLUTE::~EXYABSOLUTE()
{

}

void EXYABSOLUTE::accept(Visitor *v)
{
  v->visitEXYABSOLUTE(this);
}

EXYABSOLUTE *EXYABSOLUTE::clone() const
{
  return new EXYABSOLUTE(*this);
}



/********************   ElementGeometry    ********************/
ElementGeometry::ElementGeometry(Geometry *p1)
{
  geometry_ = p1;

}

ElementGeometry::ElementGeometry(const ElementGeometry & other)
{
  geometry_ = other.geometry_->clone();

}

ElementGeometry &ElementGeometry::operator=(const ElementGeometry & other)
{
  ElementGeometry tmp(other);
  swap(tmp);
  return *this;
}

void ElementGeometry::swap(ElementGeometry & other)
{
  std::swap(geometry_, other.geometry_);

}

ElementGeometry::~ElementGeometry()
{
  delete(geometry_);

}

void ElementGeometry::accept(Visitor *v)
{
  v->visitElementGeometry(this);
}

ElementGeometry *ElementGeometry::clone() const
{
  return new ElementGeometry(*this);
}



/********************   ElementPLACEMENT    ********************/
ElementPLACEMENT::ElementPLACEMENT(PLACEMENT *p1)
{
  placement_ = p1;

}

ElementPLACEMENT::ElementPLACEMENT(const ElementPLACEMENT & other)
{
  placement_ = other.placement_->clone();

}

ElementPLACEMENT &ElementPLACEMENT::operator=(const ElementPLACEMENT & other)
{
  ElementPLACEMENT tmp(other);
  swap(tmp);
  return *this;
}

void ElementPLACEMENT::swap(ElementPLACEMENT & other)
{
  std::swap(placement_, other.placement_);

}

ElementPLACEMENT::~ElementPLACEMENT()
{
  delete(placement_);

}

void ElementPLACEMENT::accept(Visitor *v)
{
  v->visitElementPLACEMENT(this);
}

ElementPLACEMENT *ElementPLACEMENT::clone() const
{
  return new ElementPLACEMENT(*this);
}



/********************   ElementTEXT    ********************/
ElementTEXT::ElementTEXT(TEXT *p1)
{
  text_ = p1;

}

ElementTEXT::ElementTEXT(const ElementTEXT & other)
{
  text_ = other.text_->clone();

}

ElementTEXT &ElementTEXT::operator=(const ElementTEXT & other)
{
  ElementTEXT tmp(other);
  swap(tmp);
  return *this;
}

void ElementTEXT::swap(ElementTEXT & other)
{
  std::swap(text_, other.text_);

}

ElementTEXT::~ElementTEXT()
{
  delete(text_);

}

void ElementTEXT::accept(Visitor *v)
{
  v->visitElementTEXT(this);
}

ElementTEXT *ElementTEXT::clone() const
{
  return new ElementTEXT(*this);
}



/********************   ElementXELEMENT    ********************/
ElementXELEMENT::ElementXELEMENT(XELEMENT *p1)
{
  xelement_ = p1;

}

ElementXELEMENT::ElementXELEMENT(const ElementXELEMENT & other)
{
  xelement_ = other.xelement_->clone();

}

ElementXELEMENT &ElementXELEMENT::operator=(const ElementXELEMENT & other)
{
  ElementXELEMENT tmp(other);
  swap(tmp);
  return *this;
}

void ElementXELEMENT::swap(ElementXELEMENT & other)
{
  std::swap(xelement_, other.xelement_);

}

ElementXELEMENT::~ElementXELEMENT()
{
  delete(xelement_);

}

void ElementXELEMENT::accept(Visitor *v)
{
  v->visitElementXELEMENT(this);
}

ElementXELEMENT *ElementXELEMENT::clone() const
{
  return new ElementXELEMENT(*this);
}



/********************   EPLACEMENT    ********************/
EPLACEMENT::EPLACEMENT()
{

}

EPLACEMENT::EPLACEMENT(const EPLACEMENT & other)
{

}

EPLACEMENT &EPLACEMENT::operator=(const EPLACEMENT & other)
{
  EPLACEMENT tmp(other);
  swap(tmp);
  return *this;
}

void EPLACEMENT::swap(EPLACEMENT & other)
{

}

EPLACEMENT::~EPLACEMENT()
{

}

void EPLACEMENT::accept(Visitor *v)
{
  v->visitEPLACEMENT(this);
}

EPLACEMENT *EPLACEMENT::clone() const
{
  return new EPLACEMENT(*this);
}



/********************   ETEXT    ********************/
ETEXT::ETEXT()
{

}

ETEXT::ETEXT(const ETEXT & other)
{

}

ETEXT &ETEXT::operator=(const ETEXT & other)
{
  ETEXT tmp(other);
  swap(tmp);
  return *this;
}

void ETEXT::swap(ETEXT & other)
{

}

ETEXT::~ETEXT()
{

}

void ETEXT::accept(Visitor *v)
{
  v->visitETEXT(this);
}

ETEXT *ETEXT::clone() const
{
  return new ETEXT(*this);
}



/********************   EXELEMENT    ********************/
EXELEMENT::EXELEMENT()
{

}

EXELEMENT::EXELEMENT(const EXELEMENT & other)
{

}

EXELEMENT &EXELEMENT::operator=(const EXELEMENT & other)
{
  EXELEMENT tmp(other);
  swap(tmp);
  return *this;
}

void EXELEMENT::swap(EXELEMENT & other)
{

}

EXELEMENT::~EXELEMENT()
{

}

void EXELEMENT::accept(Visitor *v)
{
  v->visitEXELEMENT(this);
}

EXELEMENT *EXELEMENT::clone() const
{
  return new EXELEMENT(*this);
}



/********************   GeometryRECTANGLE    ********************/
GeometryRECTANGLE::GeometryRECTANGLE(RECTANGLE *p1)
{
  rectangle_ = p1;

}

GeometryRECTANGLE::GeometryRECTANGLE(const GeometryRECTANGLE & other)
{
  rectangle_ = other.rectangle_->clone();

}

GeometryRECTANGLE &GeometryRECTANGLE::operator=(const GeometryRECTANGLE & other)
{
  GeometryRECTANGLE tmp(other);
  swap(tmp);
  return *this;
}

void GeometryRECTANGLE::swap(GeometryRECTANGLE & other)
{
  std::swap(rectangle_, other.rectangle_);

}

GeometryRECTANGLE::~GeometryRECTANGLE()
{
  delete(rectangle_);

}

void GeometryRECTANGLE::accept(Visitor *v)
{
  v->visitGeometryRECTANGLE(this);
}

GeometryRECTANGLE *GeometryRECTANGLE::clone() const
{
  return new GeometryRECTANGLE(*this);
}



/********************   GeometryPOLYGON    ********************/
GeometryPOLYGON::GeometryPOLYGON(POLYGON *p1)
{
  polygon_ = p1;

}

GeometryPOLYGON::GeometryPOLYGON(const GeometryPOLYGON & other)
{
  polygon_ = other.polygon_->clone();

}

GeometryPOLYGON &GeometryPOLYGON::operator=(const GeometryPOLYGON & other)
{
  GeometryPOLYGON tmp(other);
  swap(tmp);
  return *this;
}

void GeometryPOLYGON::swap(GeometryPOLYGON & other)
{
  std::swap(polygon_, other.polygon_);

}

GeometryPOLYGON::~GeometryPOLYGON()
{
  delete(polygon_);

}

void GeometryPOLYGON::accept(Visitor *v)
{
  v->visitGeometryPOLYGON(this);
}

GeometryPOLYGON *GeometryPOLYGON::clone() const
{
  return new GeometryPOLYGON(*this);
}



/********************   GeometryPATH    ********************/
GeometryPATH::GeometryPATH(PATH *p1)
{
  path_ = p1;

}

GeometryPATH::GeometryPATH(const GeometryPATH & other)
{
  path_ = other.path_->clone();

}

GeometryPATH &GeometryPATH::operator=(const GeometryPATH & other)
{
  GeometryPATH tmp(other);
  swap(tmp);
  return *this;
}

void GeometryPATH::swap(GeometryPATH & other)
{
  std::swap(path_, other.path_);

}

GeometryPATH::~GeometryPATH()
{
  delete(path_);

}

void GeometryPATH::accept(Visitor *v)
{
  v->visitGeometryPATH(this);
}

GeometryPATH *GeometryPATH::clone() const
{
  return new GeometryPATH(*this);
}



/********************   GeometryTRAPEZOID    ********************/
GeometryTRAPEZOID::GeometryTRAPEZOID(TRAPEZOID *p1)
{
  trapezoid_ = p1;

}

GeometryTRAPEZOID::GeometryTRAPEZOID(const GeometryTRAPEZOID & other)
{
  trapezoid_ = other.trapezoid_->clone();

}

GeometryTRAPEZOID &GeometryTRAPEZOID::operator=(const GeometryTRAPEZOID & other)
{
  GeometryTRAPEZOID tmp(other);
  swap(tmp);
  return *this;
}

void GeometryTRAPEZOID::swap(GeometryTRAPEZOID & other)
{
  std::swap(trapezoid_, other.trapezoid_);

}

GeometryTRAPEZOID::~GeometryTRAPEZOID()
{
  delete(trapezoid_);

}

void GeometryTRAPEZOID::accept(Visitor *v)
{
  v->visitGeometryTRAPEZOID(this);
}

GeometryTRAPEZOID *GeometryTRAPEZOID::clone() const
{
  return new GeometryTRAPEZOID(*this);
}



/********************   GeometryCTRAPEZOID    ********************/
GeometryCTRAPEZOID::GeometryCTRAPEZOID(CTRAPEZOID *p1)
{
  ctrapezoid_ = p1;

}

GeometryCTRAPEZOID::GeometryCTRAPEZOID(const GeometryCTRAPEZOID & other)
{
  ctrapezoid_ = other.ctrapezoid_->clone();

}

GeometryCTRAPEZOID &GeometryCTRAPEZOID::operator=(const GeometryCTRAPEZOID & other)
{
  GeometryCTRAPEZOID tmp(other);
  swap(tmp);
  return *this;
}

void GeometryCTRAPEZOID::swap(GeometryCTRAPEZOID & other)
{
  std::swap(ctrapezoid_, other.ctrapezoid_);

}

GeometryCTRAPEZOID::~GeometryCTRAPEZOID()
{
  delete(ctrapezoid_);

}

void GeometryCTRAPEZOID::accept(Visitor *v)
{
  v->visitGeometryCTRAPEZOID(this);
}

GeometryCTRAPEZOID *GeometryCTRAPEZOID::clone() const
{
  return new GeometryCTRAPEZOID(*this);
}



/********************   GeometryCIRCLE    ********************/
GeometryCIRCLE::GeometryCIRCLE(CIRCLE *p1)
{
  circle_ = p1;

}

GeometryCIRCLE::GeometryCIRCLE(const GeometryCIRCLE & other)
{
  circle_ = other.circle_->clone();

}

GeometryCIRCLE &GeometryCIRCLE::operator=(const GeometryCIRCLE & other)
{
  GeometryCIRCLE tmp(other);
  swap(tmp);
  return *this;
}

void GeometryCIRCLE::swap(GeometryCIRCLE & other)
{
  std::swap(circle_, other.circle_);

}

GeometryCIRCLE::~GeometryCIRCLE()
{
  delete(circle_);

}

void GeometryCIRCLE::accept(Visitor *v)
{
  v->visitGeometryCIRCLE(this);
}

GeometryCIRCLE *GeometryCIRCLE::clone() const
{
  return new GeometryCIRCLE(*this);
}



/********************   GeometryXGEOMETRY    ********************/
GeometryXGEOMETRY::GeometryXGEOMETRY(XGEOMETRY *p1)
{
  xgeometry_ = p1;

}

GeometryXGEOMETRY::GeometryXGEOMETRY(const GeometryXGEOMETRY & other)
{
  xgeometry_ = other.xgeometry_->clone();

}

GeometryXGEOMETRY &GeometryXGEOMETRY::operator=(const GeometryXGEOMETRY & other)
{
  GeometryXGEOMETRY tmp(other);
  swap(tmp);
  return *this;
}

void GeometryXGEOMETRY::swap(GeometryXGEOMETRY & other)
{
  std::swap(xgeometry_, other.xgeometry_);

}

GeometryXGEOMETRY::~GeometryXGEOMETRY()
{
  delete(xgeometry_);

}

void GeometryXGEOMETRY::accept(Visitor *v)
{
  v->visitGeometryXGEOMETRY(this);
}

GeometryXGEOMETRY *GeometryXGEOMETRY::clone() const
{
  return new GeometryXGEOMETRY(*this);
}



/********************   EPOLYGON    ********************/
EPOLYGON::EPOLYGON()
{

}

EPOLYGON::EPOLYGON(const EPOLYGON & other)
{

}

EPOLYGON &EPOLYGON::operator=(const EPOLYGON & other)
{
  EPOLYGON tmp(other);
  swap(tmp);
  return *this;
}

void EPOLYGON::swap(EPOLYGON & other)
{

}

EPOLYGON::~EPOLYGON()
{

}

void EPOLYGON::accept(Visitor *v)
{
  v->visitEPOLYGON(this);
}

EPOLYGON *EPOLYGON::clone() const
{
  return new EPOLYGON(*this);
}



/********************   EPATH    ********************/
EPATH::EPATH()
{

}

EPATH::EPATH(const EPATH & other)
{

}

EPATH &EPATH::operator=(const EPATH & other)
{
  EPATH tmp(other);
  swap(tmp);
  return *this;
}

void EPATH::swap(EPATH & other)
{

}

EPATH::~EPATH()
{

}

void EPATH::accept(Visitor *v)
{
  v->visitEPATH(this);
}

EPATH *EPATH::clone() const
{
  return new EPATH(*this);
}



/********************   ETRAPEZOID    ********************/
ETRAPEZOID::ETRAPEZOID()
{

}

ETRAPEZOID::ETRAPEZOID(const ETRAPEZOID & other)
{

}

ETRAPEZOID &ETRAPEZOID::operator=(const ETRAPEZOID & other)
{
  ETRAPEZOID tmp(other);
  swap(tmp);
  return *this;
}

void ETRAPEZOID::swap(ETRAPEZOID & other)
{

}

ETRAPEZOID::~ETRAPEZOID()
{

}

void ETRAPEZOID::accept(Visitor *v)
{
  v->visitETRAPEZOID(this);
}

ETRAPEZOID *ETRAPEZOID::clone() const
{
  return new ETRAPEZOID(*this);
}



/********************   ECTRAPEZOID    ********************/
ECTRAPEZOID::ECTRAPEZOID()
{

}

ECTRAPEZOID::ECTRAPEZOID(const ECTRAPEZOID & other)
{

}

ECTRAPEZOID &ECTRAPEZOID::operator=(const ECTRAPEZOID & other)
{
  ECTRAPEZOID tmp(other);
  swap(tmp);
  return *this;
}

void ECTRAPEZOID::swap(ECTRAPEZOID & other)
{

}

ECTRAPEZOID::~ECTRAPEZOID()
{

}

void ECTRAPEZOID::accept(Visitor *v)
{
  v->visitECTRAPEZOID(this);
}

ECTRAPEZOID *ECTRAPEZOID::clone() const
{
  return new ECTRAPEZOID(*this);
}



/********************   ECIRCLE    ********************/
ECIRCLE::ECIRCLE()
{

}

ECIRCLE::ECIRCLE(const ECIRCLE & other)
{

}

ECIRCLE &ECIRCLE::operator=(const ECIRCLE & other)
{
  ECIRCLE tmp(other);
  swap(tmp);
  return *this;
}

void ECIRCLE::swap(ECIRCLE & other)
{

}

ECIRCLE::~ECIRCLE()
{

}

void ECIRCLE::accept(Visitor *v)
{
  v->visitECIRCLE(this);
}

ECIRCLE *ECIRCLE::clone() const
{
  return new ECIRCLE(*this);
}



/********************   EXGEOMETRY    ********************/
EXGEOMETRY::EXGEOMETRY()
{

}

EXGEOMETRY::EXGEOMETRY(const EXGEOMETRY & other)
{

}

EXGEOMETRY &EXGEOMETRY::operator=(const EXGEOMETRY & other)
{
  EXGEOMETRY tmp(other);
  swap(tmp);
  return *this;
}

void EXGEOMETRY::swap(EXGEOMETRY & other)
{

}

EXGEOMETRY::~EXGEOMETRY()
{

}

void EXGEOMETRY::accept(Visitor *v)
{
  v->visitEXGEOMETRY(this);
}

EXGEOMETRY *EXGEOMETRY::clone() const
{
  return new EXGEOMETRY(*this);
}



/********************   ERECTANGLE    ********************/
ERECTANGLE::ERECTANGLE(RectangleInfoByte *p1, LayerData *p2, ListWidth *p3, ListHeight *p4, ListXCoord *p5, ListYCoord *p6, ListRepetition *p7)
{
  rectangleinfobyte_ = p1;
  layerdata_ = p2;
  listwidth_ = p3;
  listheight_ = p4;
  listxcoord_ = p5;
  listycoord_ = p6;
  listrepetition_ = p7;

}

ERECTANGLE::ERECTANGLE(const ERECTANGLE & other)
{
  rectangleinfobyte_ = other.rectangleinfobyte_->clone();
  layerdata_ = other.layerdata_->clone();
  listwidth_ = other.listwidth_->clone();
  listheight_ = other.listheight_->clone();
  listxcoord_ = other.listxcoord_->clone();
  listycoord_ = other.listycoord_->clone();
  listrepetition_ = other.listrepetition_->clone();

}

ERECTANGLE &ERECTANGLE::operator=(const ERECTANGLE & other)
{
  ERECTANGLE tmp(other);
  swap(tmp);
  return *this;
}

void ERECTANGLE::swap(ERECTANGLE & other)
{
  std::swap(rectangleinfobyte_, other.rectangleinfobyte_);
  std::swap(layerdata_, other.layerdata_);
  std::swap(listwidth_, other.listwidth_);
  std::swap(listheight_, other.listheight_);
  std::swap(listxcoord_, other.listxcoord_);
  std::swap(listycoord_, other.listycoord_);
  std::swap(listrepetition_, other.listrepetition_);

}

ERECTANGLE::~ERECTANGLE()
{
  delete(rectangleinfobyte_);
  delete(layerdata_);
  delete(listwidth_);
  delete(listheight_);
  delete(listxcoord_);
  delete(listycoord_);
  delete(listrepetition_);

}

void ERECTANGLE::accept(Visitor *v)
{
  v->visitERECTANGLE(this);
}

ERECTANGLE *ERECTANGLE::clone() const
{
  return new ERECTANGLE(*this);
}



/********************   ERectangleInfoByte    ********************/
ERectangleInfoByte::ERectangleInfoByte(Int *p1)
{
  int_ = p1;

}

ERectangleInfoByte::ERectangleInfoByte(const ERectangleInfoByte & other)
{
  int_ = other.int_->clone();

}

ERectangleInfoByte &ERectangleInfoByte::operator=(const ERectangleInfoByte & other)
{
  ERectangleInfoByte tmp(other);
  swap(tmp);
  return *this;
}

void ERectangleInfoByte::swap(ERectangleInfoByte & other)
{
  std::swap(int_, other.int_);

}

ERectangleInfoByte::~ERectangleInfoByte()
{
  delete(int_);

}

void ERectangleInfoByte::accept(Visitor *v)
{
  v->visitERectangleInfoByte(this);
}

ERectangleInfoByte *ERectangleInfoByte::clone() const
{
  return new ERectangleInfoByte(*this);
}



/********************   ELayerData    ********************/
ELayerData::ELayerData(LayerNumber *p1, DataTypeNumber *p2)
{
  layernumber_ = p1;
  datatypenumber_ = p2;

}

ELayerData::ELayerData(const ELayerData & other)
{
  layernumber_ = other.layernumber_->clone();
  datatypenumber_ = other.datatypenumber_->clone();

}

ELayerData &ELayerData::operator=(const ELayerData & other)
{
  ELayerData tmp(other);
  swap(tmp);
  return *this;
}

void ELayerData::swap(ELayerData & other)
{
  std::swap(layernumber_, other.layernumber_);
  std::swap(datatypenumber_, other.datatypenumber_);

}

ELayerData::~ELayerData()
{
  delete(layernumber_);
  delete(datatypenumber_);

}

void ELayerData::accept(Visitor *v)
{
  v->visitELayerData(this);
}

ELayerData *ELayerData::clone() const
{
  return new ELayerData(*this);
}



/********************   ELayerNumber    ********************/
ELayerNumber::ELayerNumber(Int *p1)
{
  int_ = p1;

}

ELayerNumber::ELayerNumber(const ELayerNumber & other)
{
  int_ = other.int_->clone();

}

ELayerNumber &ELayerNumber::operator=(const ELayerNumber & other)
{
  ELayerNumber tmp(other);
  swap(tmp);
  return *this;
}

void ELayerNumber::swap(ELayerNumber & other)
{
  std::swap(int_, other.int_);

}

ELayerNumber::~ELayerNumber()
{
  delete(int_);

}

void ELayerNumber::accept(Visitor *v)
{
  v->visitELayerNumber(this);
}

ELayerNumber *ELayerNumber::clone() const
{
  return new ELayerNumber(*this);
}



/********************   EDataTypeNumber    ********************/
EDataTypeNumber::EDataTypeNumber(Int *p1)
{
  int_ = p1;

}

EDataTypeNumber::EDataTypeNumber(const EDataTypeNumber & other)
{
  int_ = other.int_->clone();

}

EDataTypeNumber &EDataTypeNumber::operator=(const EDataTypeNumber & other)
{
  EDataTypeNumber tmp(other);
  swap(tmp);
  return *this;
}

void EDataTypeNumber::swap(EDataTypeNumber & other)
{
  std::swap(int_, other.int_);

}

EDataTypeNumber::~EDataTypeNumber()
{
  delete(int_);

}

void EDataTypeNumber::accept(Visitor *v)
{
  v->visitEDataTypeNumber(this);
}

EDataTypeNumber *EDataTypeNumber::clone() const
{
  return new EDataTypeNumber(*this);
}



/********************   EWidth    ********************/
EWidth::EWidth(Int *p1)
{
  int_ = p1;

}

EWidth::EWidth(const EWidth & other)
{
  int_ = other.int_->clone();

}

EWidth &EWidth::operator=(const EWidth & other)
{
  EWidth tmp(other);
  swap(tmp);
  return *this;
}

void EWidth::swap(EWidth & other)
{
  std::swap(int_, other.int_);

}

EWidth::~EWidth()
{
  delete(int_);

}

void EWidth::accept(Visitor *v)
{
  v->visitEWidth(this);
}

EWidth *EWidth::clone() const
{
  return new EWidth(*this);
}



/********************   EHeight    ********************/
EHeight::EHeight(Int *p1)
{
  int_ = p1;

}

EHeight::EHeight(const EHeight & other)
{
  int_ = other.int_->clone();

}

EHeight &EHeight::operator=(const EHeight & other)
{
  EHeight tmp(other);
  swap(tmp);
  return *this;
}

void EHeight::swap(EHeight & other)
{
  std::swap(int_, other.int_);

}

EHeight::~EHeight()
{
  delete(int_);

}

void EHeight::accept(Visitor *v)
{
  v->visitEHeight(this);
}

EHeight *EHeight::clone() const
{
  return new EHeight(*this);
}



/********************   EXCoord    ********************/
EXCoord::EXCoord(Int *p1)
{
  int_ = p1;

}

EXCoord::EXCoord(const EXCoord & other)
{
  int_ = other.int_->clone();

}

EXCoord &EXCoord::operator=(const EXCoord & other)
{
  EXCoord tmp(other);
  swap(tmp);
  return *this;
}

void EXCoord::swap(EXCoord & other)
{
  std::swap(int_, other.int_);

}

EXCoord::~EXCoord()
{
  delete(int_);

}

void EXCoord::accept(Visitor *v)
{
  v->visitEXCoord(this);
}

EXCoord *EXCoord::clone() const
{
  return new EXCoord(*this);
}



/********************   EYCoord    ********************/
EYCoord::EYCoord(Int *p1)
{
  int_ = p1;

}

EYCoord::EYCoord(const EYCoord & other)
{
  int_ = other.int_->clone();

}

EYCoord &EYCoord::operator=(const EYCoord & other)
{
  EYCoord tmp(other);
  swap(tmp);
  return *this;
}

void EYCoord::swap(EYCoord & other)
{
  std::swap(int_, other.int_);

}

EYCoord::~EYCoord()
{
  delete(int_);

}

void EYCoord::accept(Visitor *v)
{
  v->visitEYCoord(this);
}

EYCoord *EYCoord::clone() const
{
  return new EYCoord(*this);
}



/********************   ERepetition    ********************/
ERepetition::ERepetition()
{

}

ERepetition::ERepetition(const ERepetition & other)
{

}

ERepetition &ERepetition::operator=(const ERepetition & other)
{
  ERepetition tmp(other);
  swap(tmp);
  return *this;
}

void ERepetition::swap(ERepetition & other)
{

}

ERepetition::~ERepetition()
{

}

void ERepetition::accept(Visitor *v)
{
  v->visitERepetition(this);
}

ERepetition *ERepetition::clone() const
{
  return new ERepetition(*this);
}



/********************   EInt    ********************/
EInt::EInt(Integer p1)
{
  integer_ = p1;

}

EInt::EInt(const EInt & other)
{
  integer_ = other.integer_;

}

EInt &EInt::operator=(const EInt & other)
{
  EInt tmp(other);
  swap(tmp);
  return *this;
}

void EInt::swap(EInt & other)
{
  std::swap(integer_, other.integer_);

}

EInt::~EInt()
{

}

void EInt::accept(Visitor *v)
{
  v->visitEInt(this);
}

EInt *EInt::clone() const
{
  return new EInt(*this);
}




/********************   ListCellData    ********************/

void ListCellData::accept(Visitor *v)
{
  v->visitListCellData(this);
}


ListCellData *ListCellData::clone() const
{
  return new ListCellData(*this);
}


/********************   ListLayerNumber    ********************/

void ListLayerNumber::accept(Visitor *v)
{
  v->visitListLayerNumber(this);
}


ListLayerNumber *ListLayerNumber::clone() const
{
  return new ListLayerNumber(*this);
}


/********************   ListDataTypeNumber    ********************/

void ListDataTypeNumber::accept(Visitor *v)
{
  v->visitListDataTypeNumber(this);
}


ListDataTypeNumber *ListDataTypeNumber::clone() const
{
  return new ListDataTypeNumber(*this);
}


/********************   ListWidth    ********************/

void ListWidth::accept(Visitor *v)
{
  v->visitListWidth(this);
}


ListWidth *ListWidth::clone() const
{
  return new ListWidth(*this);
}


/********************   ListHeight    ********************/

void ListHeight::accept(Visitor *v)
{
  v->visitListHeight(this);
}


ListHeight *ListHeight::clone() const
{
  return new ListHeight(*this);
}


/********************   ListXCoord    ********************/

void ListXCoord::accept(Visitor *v)
{
  v->visitListXCoord(this);
}


ListXCoord *ListXCoord::clone() const
{
  return new ListXCoord(*this);
}


/********************   ListYCoord    ********************/

void ListYCoord::accept(Visitor *v)
{
  v->visitListYCoord(this);
}


ListYCoord *ListYCoord::clone() const
{
  return new ListYCoord(*this);
}


/********************   ListRepetition    ********************/

void ListRepetition::accept(Visitor *v)
{
  v->visitListRepetition(this);
}


ListRepetition *ListRepetition::clone() const
{
  return new ListRepetition(*this);
}



}
